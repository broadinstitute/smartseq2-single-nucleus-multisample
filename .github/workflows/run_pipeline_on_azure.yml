name: PDT Azure CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "develop" and "master" branch
  pull_request:
    branches: [ "develop", "master" ]
    # paths:
    #   - '3rd-party-tools/zcall/**'
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker Image Tag (default: branch_name)' 

env:
  PROJECT_NAME: MultiSample SmartSeq2 Single Nucleus
  # Github repo name
#   REPOSITORY_NAME: ${{ github.event.repository.name }}
#   # Region-specific Google Docker repository where GOOGLE_PROJECT/REPOSITORY_NAME can be found
#   DOCKER_REGISTRY: us.gcr.io
#   GCR_PATH: broad-gotc-prod/zcall
#   ACR_PATH: zcall
  # The tag for the Docker imageAZURE_SUBSCRIPTION_ID="d44cb7d1-184a-4202-b1de-1ffe54218e99"
  AZURE_RESOURCE_GROUP_NAME: dsp-pipeline-dev
  AZURE_AKS_NAME: pdt-a1b950246124be
  AZURE_SUBSCRIPTION_ID: d44cb7d1-184a-4202-b1de-1ffe54218e99

  TAG: ${{ github.event.inputs.image_tag || github.head_ref || github.ref_name }}

  # A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # The job that builds our container
#   build-for-gcr:
#     runs-on: ubuntu-latest
#     defaults:
#       run:
#         working-directory: 3rd-party-tools/zcall
#     # Map a step output to a job output
#     outputs:
#       imagePath: ${{ steps.saveImagePath.outputs.url }}
#     steps:
#     # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
#     - uses: actions/checkout@v3
#     - name: Build the Docker image
#       run: docker build . --file Dockerfile --tag ${DOCKER_REGISTRY}/${GCR_PATH}:${TAG}
#     - name: Check working directory'
#       run: |
#         echo "Current directory: "
#         pwd
#         ls -lht
#     # Save the image path to an output
#     - id: 'saveImagePath'
#       run: echo "url=${DOCKER_REGISTRY}/${GCR_PATH}:${TAG}" >> $GITHUB_OUTPUT
#     # Log into the Google Docker registry
#     - id: 'Auth'
#       name: Login to GCR
#       uses: docker/login-action@v2
#       with:
#         registry: ${{ env.DOCKER_REGISTRY }}
#         username: _json_key
#         password: ${{ secrets.GCR_CI_KEY }}
#     # Push the image to the Google Docker registry
#     - name: Push image
#       run: "docker push ${DOCKER_REGISTRY}/${GCR_PATH}:${TAG}"

  run-on-azure:
    runs-on: ubuntu-latest
    # defaults:
    #   run:
    #     working-directory: 3rd-party-tools/zcall
    steps:
    # checkout the repo
    - name: 'Checkout GitHub Action'
      uses: actions/checkout@v3
      
    - name: 'Login via Azure CLI'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: 'Say hello'
      run: echo Hello world
    
    - name: 'Connect to Kube and Show Pods'
      run: |
        az aks get-credentials --resource-group ${AZURE_RESOURCE_GROUP_NAME} --name ${AZURE_AKS_NAME} --subscription ${AZURE_SUBSCRIPTION_ID} --file ~/.kube/config
        kubectl -n coa get svc

    - name: 'Set-up Port Forwarding and Run Cromshell'
      run: |
        kubectl port-forward -n coa svc/cromwell 8000:8000 2>&1 &
        pid=$!
        echo pid: $pid
        while ! nc -vz localhost 8000 > /dev/null 2>&1 ; do
          # echo sleeping
          sleep 1
        done
        echo "Cromwell is up!"
        #Test run cromshell
        export CROMWELL_URL=localhost:8000;cromshell status 113556d4-ac73-492e-bf9d-03eb5edcf469
        kill $pid